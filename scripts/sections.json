{
  "backbone_01": [
    {"range": [1,23], "types": ["backbone", "fetch"],
    "notes": "<div class='label label-primary'>Fetch</div> the data with a Backbone <code>Collection</code>, as the data is an array.<br>Specify the <code>url</code> where the data lives, and call <code>fetch</code> on the Collection later on in the code.<br><br>Write some functions to crunch the data, which the Backbone <code>View</code> will use.<br><br>(This is also where all the validation code will also ideally go, but have been omitted for concision and laziness.)"},
    {"range": [24,28], "types": ["backbone", "render"]},
    {"range": [29,29], "types": ["backbone", "update"],
    "notes": "Whenever the collection <div class='label label-info'>updates</div>, re-<code>render</code>."},
    {"range": [30,67], "types": ["backbone", "render"],
    "notes": "<br><br><br>Ask <code>Collection</code> for the hours the party starts from and goes until and <div class='label label-success'>render</div> them as buttons with <code>renderTime</code>.<br><br>Then ask <code>Collection</code> for the partiers in the party at the given time.  <div class='label label-success'>Render</div> them as labels."},
    {"range": [68,79], "types": ["backbone", "update"],
    "notes": "When another time is selected, save the selected time and <div class='label label-info'>update</div> by re-<code>render</code>ing."},
    {"range": [80,80], "types": ["backbone", "fetch"],
    "notes": "Instantiate the <code>Collection</code>, because OOP."},
    {"range": [81,84], "types": ["backbone", "render"],
    "notes": "Instantiate the <code>View</code>, because OOP."},
    {"range": [85,85], "types": ["backbone", "fetch"]}
  ],
  "d3_01": [
    {"range": [1,24], "types": ["d3", "fetch"],
    "notes": "<div class='label label-primary'>Fetch</div> party data with <code>d3.json</code>, which passes back the response as a Javascript object.<br><br>The code to calculate the times and attending partiers are almost exactly the same as in the Backbone case."},
    {"range": [25, 72], "types": ["d3", "render"],
    "notes": "Here's where things are different.<br><br>One of the key concepts of D3 is <code>data</code> binding: take a set of DOM elements, and bind the first element in the data array to the first element in the DOM selection, and so on.<br><br>Then use <code>enter</code> coupled with <code>append</code> to create as many <code>.partyTime</code> elements as there are extra elements in the data array."},
    {"range": [73,112], "types": ["d3", "update"],
    "notes": "<div class='label label-info'>Updating</div> with D3 is very different also; we use a concept called <code>enter</code>-update-<code>exit</code>.<br><br>With <code>enter</code>, we append the elements in the data that don't exist in the DOM.<br><br>With <code>exit</code>, we <code>remove</code> any DOM elements that no longer exist in the data array.<br><br>And for any changes in attribute, we can use one of the following D3 functions to update: <code>.attr</code>, <code>.style</code>, <code>.text</code>, etc."}
  ],
  "backboned3_01": [
    {"range": [1,69], "types": ["backbone", "fetch"],
    "notes": "This time, <div class='label label-primary'>fetch</div> the data from <code>localhost</code>.  Also add <code>save</code> and <code>reset</code> capabilities.<br><br><br>Instead of <code>getPartiersAtTime</code> as in the previous example, use <code>getGraphAtTime</code> to calculate the nodes (partiers) and links (partiers talking to each other) at a given time."},
    {"range": [70,78], "types": ["backbone", "render"]},
    {"range": [79,79], "types": ["backbone", "update"]},
    {"range": [80,97], "types": ["backbone", "render"]},
    {"range": [98,134], "types": ["backbone", "update"]},
    {"range": [135,138], "types": ["backbone", "render"]},
    {"range": [139,145], "types": ["d3", "render"],
    "notes": "D3's <code>force</code> layout is a convenient set of functions for calculating the x- and y-positions for a graph's <code>nodes</code> and <code>links</code>."},
    {"range": [146,146], "types": ["backbone", "update"]},
    {"range": [147,160], "types": ["backbone", "render"],
    "notes": "On every <div class='label label-info'>update</div>, <code>empty</code> the DOM element and re-<div class='label label-success'>render</div> the nodes and links.  Because of the re-render, the transitions between each state may be inconsistent."},
    {"range": [161,222], "types": ["d3", "render"],
    "notes": "<div class='label label-success'>Render</div> the node as an SVG <code>g</code>roup element, with a <code>rect</code>angle for the background box, and a <code>text</code> element for the partier's name.<br><br>Render the link as a <code>line</code> element.<br><br>D3's <code>force</code> layout calculates the position of each node by simulating the force between each node over a few thousand iterations.  At each tick, the <code>onTick</code> function is called, and the <code>nodes</code> and <code>links</code> are positioned according to the x- and y-positions calculated at that iteration."},
    {"range": [223, 223], "types": ["backbone", "fetch"]},
    {"range": [224, 227], "types": ["backbone", "render"]},
    {"range": [228, 228], "types": ["backbone", "fetch"]}
  ],
  "backboned3_02": [
    {"range": [1,70], "types": ["backbone", "fetch"]},
    {"range": [71,74], "types": ["backbone", "render"]},
    {"range": [75,79], "types": ["d3", "render"],
    "notes": "Pass configurations into <code>GraphVisualization</code>, and initialize it by passing in the SVG element (<code>$('.graph')[0]</code>)."},
    {"range": [80,98], "types": ["backbone", "render"]},
    {"range": [99,102], "types": ["backbone", "update"]},
    {"range": [103,106], "types": ["d3", "update"],
    "notes": "Pass the updated graph data into <code>GraphVisualization</code>, and call <code>update</code>."},
    {"range": [107,146], "types": ["backbone", "update"]},
    {"range": [147,165], "types": ["d3", "render"],
    "notes": "<code>GraphVisualization</code> follows <a href='https://twitter.com/mbostock' target='_new'>mbostock</a>'s outline for <a href='http://bost.ocks.org/mike/chart/' target='_new'>Reusable Charts</a> and wraps D3 code in a function.<br><br>Executing <code>GraphVisualization</code> returns the inner function <code>Graph</code>, which exposes functions such as <code>update</code> and <code>data</code> that other parts of the code can interact with."},
    {"range": [166,260], "types": ["d3", "update"],
    "notes": "<div class='label label-info'>Update</div> nodes and links by using <code>enter</code> and <code>exit</code>, and updating with <code>attr</code> and <code>text</code> functions.  Because the elements aren't re-rendered on each update, the transition between each state is relatively smooth."},
    {"range": [261,281], "types": ["d3", "render"]},
    {"range": [282,282], "types": ["backbone", "fetch"]},
    {"range": [283,286], "types": ["backbone", "render"]},
    {"range": [287,287], "types": ["backbone", "fetch"]}
  ],
  "backboned3_03": [
    {"range": [1,96], "types": ["backbone", "fetch"],
    "notes": "Since <code>PartyCollection</code> keeps track of all the actions taken at the party, and the graph renders the nodes (partiers) and links (talking between partiers) derived from that data, create a <code>GraphCollection</code>.<br><br><code>GraphCollection</code> listens to updates from <code>PartyCollection</code>, recalculates the nodes and links based on the update, and sets the new nodes and links.  This then triggers the correct <code>add</code>, <code>remove</code>, and <code>change</code> events.  "},
    {"range": [97,101], "types": ["backbone", "render"]},
    {"range": [101,105], "types": ["d3", "render"]},
    {"range": [106,110], "types": ["backbone", "update"]},
    {"range": [111, 127], "types": ["backbone", "render"]},
    {"range": [128,210], "types": ["backbone", "update"],
    "notes": "Listen to <code>add</code> event on <code>GraphCollection</code>, and loop through the models.  For every node element, call <code>addNode</code> on <code>graphVisualization</code>.  Because we want to listen to changes on the node itself (color of node changing, for example), for each added model, subscribe to a <code>change</code> event and pass in a callback that calls <code>updateNode</code>.<br><br>For the links, first expand its source and target to point to the correct source and target node models instead of the strings it previously returned (this is for the <code>force</code> layout, which needs either the index of the source and target nodes or the object itself.  Call <code>addLink</code> on <code>graphVisualization</code>.<br><br>Go through similar process with Backbone <code>remove</code>event, but this time call <code>removeNode</code> and <code>removeLink</code> instead."},
    {"range": [211,229], "types": ["d3", "render"]},
    {"range": [230,329], "types": ["d3", "update"],
    "notes": "When adding a node to the SVG, <code>append</code> like normal; the <code>enter</code> functions is no longer needed, as <code>AppView</code> had done the iterating above.  Bind the data to the single node selection with <code>datum</code>.<br><br>To update, find the node whose datum matches the Backbone model being passed into <code>updateNode</code>, and update its attributes.<br><br>Similarly, filter for the node whose datum matches the model passed in to <code>removeNode</code>, and remove it from the DOM."},
    {"range": [330,350], "types": ["d3", "render"]},
    {"range": [351,354], "types": ["backbone", "fetch"]},
    {"range": [355,359], "types": ["backbone", "render"]},
    {"range": [360,360], "types": ["backbone", "fetch"]}
  ]
}